<!DOCTYPE html>
<html>
<head>
  <title>IRC Server</title>
  <style>
    body { font-family: sans-serif; background: #1e1e2f; color: #f0f0f0; margin: 20px; }
    textarea, input { background: #2d2d3a; color: white; border: 1px solid #444; border-radius: 6px; padding: 8px; }
    textarea { width: 100%; box-sizing: border-box; margin-bottom: 10px; }
    input { width: calc(100% - 120px); margin-right: 10px; }
    .btn { padding: 8px 12px; margin: 4px 4px 4px 0; background: #3a3a4f; color: white; border: none; border-radius: 6px; cursor: pointer; }
    .btn:hover { background: #50506f; }
  </style>
</head>
<body>
  <h1>IRC Server</h1>
  <h3>Paste Client Offer</h3>
  <textarea id="offerInput" rows="6" placeholder="Paste client offer here"></textarea><br>
  <button class="btn" onclick="acceptConnection()">Accept Connection</button>

  <h3>Send This Answer to Client</h3>
  <textarea id="answerOutput" rows="6" readonly></textarea>

  <h3>Chat Log</h3>
  <textarea id="log" rows="15" readonly></textarea><br>
  <input id="serverMsg" placeholder="Server message...">
  <button class="btn" onclick="broadcast()">Send to All</button>
  <button class="btn" onclick="disconnectAll()">Disconnect All</button>

  <h3>Log Controls</h3>
  <button class="btn" onclick="exportLogs()">Export Chat Log</button>
  <input type="file" id="importLogFile" onchange="importLogs(event)" />

  <script>
    const peers = [];
    const channels = { "#general": [] };
    const roles = new Map();
    const passwords = {};
    const channelTopics = {};
    const emojiMap = { smile: "😄", fire: "🔥", wave: "👋", heart: "❤️", thumbsup: "👍" };
    const chatHistory = [];
    const wsPlaceholder = null; // Placeholder for future WebSocket signaling

    const log = msg => {
      const logBox = document.getElementById("log");
      logBox.value += msg + '\n';
      logBox.scrollTop = logBox.scrollHeight;
      chatHistory.push(msg);
    };

    const sendToPeer = (peer, msg) => {
      if (peer.channel.readyState === "open") {
        peer.channel.send(msg);
      }
    };

    const broadcastToChannel = (channel, msg) => {
      channels[channel]?.forEach(p => sendToPeer(p, msg));
    };

    const switchChannel = (peer, channel) => {
      if (!channels[channel]) channels[channel] = [];
      if (peer.currentChannel) {
        channels[peer.currentChannel] = channels[peer.currentChannel].filter(p => p !== peer);
      }
      channels[channel].push(peer);
      peer.currentChannel = channel;
    };

    function handleMessage(peer, text) {
      if (text.startsWith("/")) {
        const parts = text.slice(1).split(" ");
        const command = parts[0].toLowerCase();
        const args = parts.slice(1);

        switch (command) {
          case "nick":
            peer.nickname = args[0];
            sendToPeer(peer, `[Server] Nickname set to ${peer.nickname}`);
            break;

          case "join":
            const [ch, pass] = args;
            if (passwords[ch] && passwords[ch] !== pass) {
              sendToPeer(peer, `[Server] Incorrect password for ${ch}`);
            } else {
              switchChannel(peer, ch);
              if (!passwords[ch] && pass) passwords[ch] = pass;
              sendToPeer(peer, `[Server] You joined ${ch}`);
            }
            break;

          case "list":
            const chList = Object.keys(channels).map(c => `${c} (${channels[c].length} users)`).join("\n- ");
            sendToPeer(peer, `[Server] Available channels:\n- ${chList}`);
            break;

          case "topic":
            const [channelName, ...topicParts] = args;
            if (!channelName || !channels[channelName]) {
              sendToPeer(peer, `[Server] Channel does not exist.`);
              break;
            }
            if (topicParts.length === 0) {
              const t = channelTopics[channelName] || "No topic set.";
              sendToPeer(peer, `[Server] Topic for ${channelName}: "${t}"`);
            } else {
              const role = roles.get(peer.channel) || "user";
              if (role === "admin" || role === "mod") {
                channelTopics[channelName] = topicParts.join(" ");
                broadcastToChannel(channelName, `[Server] Topic for ${channelName} set to: "${channelTopics[channelName]}"`);
              } else {
                sendToPeer(peer, `[Server] You don’t have permission to set topics.`);
              }
            }
            break;

          case "role":
            if (roles.get(peer.channel) !== "admin") {
              sendToPeer(peer, `[Server] Only admin can assign roles.`);
              break;
            }
            const [targetNick, newRole] = args;
            const targetPeer = peers.find(p => p.nickname === targetNick);
            if (targetPeer && ["admin", "mod", "user"].includes(newRole)) {
              roles.set(targetPeer.channel, newRole);
              sendToPeer(peer, `[Server] Set role of ${targetNick} to ${newRole}`);
              sendToPeer(targetPeer, `[Server] Your role is now ${newRole}`);
            } else {
              sendToPeer(peer, `[Server] Invalid target or role.`);
            }
            break;

          case "msg":
            const [target, ...msgParts] = args;
            const targetPeer = peers.find(p => p.nickname === target);
            if (targetPeer) {
              sendToPeer(targetPeer, `[PRIVATE] ${peer.nickname}: ${msgParts.join(" ")}`);
              sendToPeer(peer, `[TO ${target}] ${peer.nickname}: ${msgParts.join(" ")}`);
            }
            break;

          case "help":
            const role = roles.get(peer.channel) || "user";
            let helpText = "[Server] Available commands:\n/nick [name]\n/join [#channel] [password]\n/list\n/topic [#channel] [topic]\n/msg [user] [msg]\n/help";
            if (role === "admin") helpText += "\n/role [nickname] [admin|mod|user]";
            sendToPeer(peer, helpText);
            break;

          default:
            sendToPeer(peer, `[Server] Unknown command: /${command}`);
        }
      } else {
        const emojiMsg = text.replace(/:(\w+):/g, (m, p1) => emojiMap[p1] || m);
        const formatted = `${peer.nickname || "Anonymous"} (${peer.currentChannel}): ${emojiMsg}`;
        log(formatted);
        broadcastToChannel(peer.currentChannel, formatted);
        new Audio("https://www.soundjay.com/buttons/sounds/button-3.mp3").play();
      }
    }

    async function acceptConnection() {
      const data = JSON.parse(document.getElementById('offerInput').value);
      const pc = new RTCPeerConnection({ iceServers: [{ urls: "stun:stun.l.google.com:19302" }] });
      const answerTextarea = document.getElementById('answerOutput');
      const iceCandidates = [];

      pc.ondatachannel = event => {
        const channel = event.channel;
        const peer = { pc, channel, nickname: "Anonymous", currentChannel: "#general" };
        roles.set(channel, "user");
        switchChannel(peer, "#general");
        peers.push(peer);
        log("[Server] New client connected.");

        channel.onmessage = e => handleMessage(peer, e.data);
      };

      await pc.setRemoteDescription(new RTCSessionDescription(data.offer));
      for (const c of data.ice) {
        await pc.addIceCandidate(new RTCIceCandidate(c));
      }
      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);
      pc.onicecandidate = e => {
        if (e.candidate) {
          iceCandidates.push(e.candidate);
        } else {
          answerTextarea.value = JSON.stringify({ answer: pc.localDescription, ice: iceCandidates }, null, 2);
        }
      };
    }

    function broadcast() {
      const msg = "Server: " + document.getElementById("serverMsg").value;
      peers.forEach(p => sendToPeer(p, msg));
      log(msg);
      document.getElementById("serverMsg").value = "";
    }

    function disconnectAll() {
      peers.forEach(p => {
        if (p.channel) p.channel.close();
        if (p.pc) p.pc.close();
      });
      peers.length = 0;
      log("[Server] All clients disconnected.");
    }

    function exportLogs() {
      const blob = new Blob([chatHistory.join("\n")], { type: "text/plain" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "chat_log.txt";
      a.click();
      URL.revokeObjectURL(url);
    }

    function importLogs(event) {
      const file = event.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = e => {
        const lines = e.target.result.split("\n");
        lines.forEach(line => log(line));
      };
      reader.readAsText(file);
    }
  </script>
</body>
</html>
