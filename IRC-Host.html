<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>IRC Server</title>
  <style>
    body { font-family: sans-serif; background: #1e1e2f; color: #f0f0f0; margin: 20px; }
    h1 { color: #82aaff; }
    textarea, input { background: #2d2d3a; color: white; border: 1px solid #444; border-radius: 6px; padding: 8px; }
    #log { width: 100%; height: 300px; overflow-y: scroll; }
    input, textarea { width: 100%; box-sizing: border-box; margin-bottom: 8px; }
    .btn { margin-right: 5px; margin-bottom: 10px; padding: 5px 10px; background: #3a3a4f; color: #fff; border: none; border-radius: 4px; cursor: pointer; }
    .btn:hover { background: #50506f; }
  </style>
</head>
<body>
  <h1>IRC Server</h1>
  <textarea id="offerInput" rows="6" placeholder="Paste client offer here..."></textarea>
  <button class="btn" onclick="acceptConnection()">Accept Connection</button>
  <textarea id="answerOutput" rows="6" readonly placeholder="Send this answer to client..."></textarea>

  <h3>Chat Log</h3>
  <textarea id="log" readonly></textarea>
  <input id="serverMsg" placeholder="Server message...">
  <button class="btn" onclick="broadcast()">Send to All</button>
  <button class="btn" onclick="disconnectAll()">Disconnect All</button>

  <h3>Log Controls</h3>
  <button class="btn" onclick="exportLog()">Export Chat Log</button>
  <input type="file" id="importLogFile" accept=".txt" />
  <button class="btn" onclick="importLog()">Import Log</button>

  <script>
    const peers = [];
    const roles = {};
    const channels = { "#general": [] };
    const passwords = {}; // channel passwords
    const logArea = document.getElementById("log");
    let chatHistory = [];

    const log = msg => {
      logArea.value += msg + "\n";
      logArea.scrollTop = logArea.scrollHeight;
      chatHistory.push(msg);
    };

    function sendToPeer(peer, msg) {
      if (peer.channel.readyState === "open") peer.channel.send(msg);
    }

    function broadcastToChannel(channel, msg) {
      (channels[channel] || []).forEach(p => sendToPeer(p, msg));
    }

    function hasRole(peer, role) {
      return roles[peer.nickname] === role || roles[peer.nickname] === "admin";
    }

    async function acceptConnection() {
      const data = JSON.parse(document.getElementById("offerInput").value);
      const pc = new RTCPeerConnection({ iceServers: [{ urls: "stun:stun.l.google.com:19302" }] });
      const iceCandidates = [];
      const answerTextarea = document.getElementById("answerOutput");

      pc.ondatachannel = event => {
        const channel = event.channel;
        const peer = { pc, channel, nickname: "Anonymous", currentChannel: "#general" };
        channels["#general"].push(peer);
        roles[peer.nickname] = "user";
        peers.push(peer);
        log(`[Server] ${peer.nickname} connected.`);

        channel.onmessage = e => handleMessage(peer, e.data);
        channel.onclose = () => {
          removePeer(peer);
          log(`[Server] ${peer.nickname} disconnected.`);
        };
      };

      await pc.setRemoteDescription(new RTCSessionDescription(data.offer));
      for (const c of data.ice) {
        await pc.addIceCandidate(new RTCIceCandidate(c));
      }
      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);
      pc.onicecandidate = e => {
        if (e.candidate) iceCandidates.push(e.candidate);
        else {
          answerTextarea.value = JSON.stringify({
            answer: pc.localDescription,
            ice: iceCandidates
          }, null, 2);
        }
      };
    }

    function handleMessage(peer, msg) {
      if (msg.startsWith("/")) {
        const [cmd, ...args] = msg.slice(1).split(" ");
        const command = cmd.toLowerCase();
        switch (command) {
          case "nick":
            const oldNick = peer.nickname;
            peer.nickname = args[0] || "Anonymous";
            roles[peer.nickname] = roles[oldNick] || "user";
            log(`[Server] ${oldNick} is now ${peer.nickname}`);
            break;

          case "join":
            const [ch, pass] = args;
            if (passwords[ch] && passwords[ch] !== pass) {
              sendToPeer(peer, `[Server] Incorrect password for ${ch}`);
            } else {
              switchChannel(peer, ch);
              if (!passwords[ch] && pass) passwords[ch] = pass;
              sendToPeer(peer, `[Server] You joined ${ch}`);
            }
            break;

          case "msg":
            const [target, ...msgParts] = args;
            const targetPeer = peers.find(p => p.nickname === target);
            if (targetPeer) {
              sendToPeer(targetPeer, `[PRIVATE] ${peer.nickname}: ${msgParts.join(" ")}`);
              sendToPeer(peer, `[TO ${target}] ${peer.nickname}: ${msgParts.join(" ")}`);
            }
            break;

          case "kick":
            if (hasRole(peer, "mod")) {
              const kickTarget = peers.find(p => p.nickname === args[0]);
              if (kickTarget) {
                sendToPeer(kickTarget, "[Server] You were kicked.");
                kickTarget.channel.close();
                removePeer(kickTarget);
              }
            } else sendToPeer(peer, "[Server] You lack permission to /kick");
            break;

          case "setrole":
            if (roles[peer.nickname] === "admin") {
              const [user, role] = args;
              if (["mod", "user"].includes(role)) {
                roles[user] = role;
                sendToPeer(peer, `[Server] ${user} set to ${role}`);
              }
            }
            break;

          case "help":
            let helpText = `Available commands:\n`;
            helpText += `/nick <name>\n/join <#channel> [pass]\n/msg <user> <msg>\n/help\n`;
            if (hasRole(peer, "mod")) helpText += `/kick <user>\n`;
            if (roles[peer.nickname] === "admin") helpText += `/setrole <user> <role>\n`;
            sendToPeer(peer, helpText);
            break;

          default:
            sendToPeer(peer, `[Server] Unknown command: ${command}`);
        }
      } else {
        const emojiMsg = msg.replace(/:(\w+):/g, (m, p1) => emojiMap[p1] || m);
        const full = `[${peer.currentChannel}] ${peer.nickname}: ${emojiMsg}`;
        log(full);
        broadcastToChannel(peer.currentChannel, full);
        new Audio("https://www.soundjay.com/buttons/sounds/button-3.mp3").play();
      }
    }

    function switchChannel(peer, channel) {
      channels[peer.currentChannel] = channels[peer.currentChannel].filter(p => p !== peer);
      if (!channels[channel]) channels[channel] = [];
      channels[channel].push(peer);
      peer.currentChannel = channel;
    }

    function removePeer(peer) {
      peers.splice(peers.indexOf(peer), 1);
      if (channels[peer.currentChannel]) {
        channels[peer.currentChannel] = channels[peer.currentChannel].filter(p => p !== peer);
      }
    }

    function broadcast() {
      const msg = "Server: " + document.getElementById("serverMsg").value;
      peers.forEach(p => sendToPeer(p, msg));
      log(msg);
      document.getElementById("serverMsg").value = "";
    }

    function disconnectAll() {
      peers.forEach(p => {
        if (p.channel) p.channel.close();
        if (p.pc) p.pc.close();
      });
      peers.length = 0;
      log("[Server] All clients disconnected.");
    }

    function exportLog() {
      const blob = new Blob([chatHistory.join("\n")], { type: "text/plain" });
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = "chat_log.txt";
      a.click();
    }

    function importLog() {
      const file = document.getElementById("importLogFile").files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = () => {
          const lines = reader.result.split("\n");
          lines.forEach(line => log(line));
        };
        reader.readAsText(file);
      }
    }

    const emojiMap = {
      smile: "üòÑ",
      fire: "üî•",
      wave: "üëã",
      heart: "‚ù§Ô∏è",
      thumbsup: "üëç"
    };
  </script>
</body>
</html>
